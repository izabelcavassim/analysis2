
"""
Snakefile for running N_t analysis on stdpopsim.

Simply running `snakemake` will run all analysis 
defined by the arguments above.

Currently, for each rep,
This will run stairway plot, smc++, and msmc
on the data resulting from simulations
on all chromosomes included in chrm_list
for estimates of N_t (Ne through time).
"""

import pathlib
import sys
import os
import numpy as np
import stdpopsim
import stairway
import smc
import msmc
import plots


# ###############################################################################
# KNOBS - 
# ###############################################################################


# A seed to replicate results
# TODO mutation rates

configfile: config["config"]+"/config.json"

np.random.seed(config["seed"])

# This is the number of samples to simulate for within each population
# for each replicate
# TODO double check this is up to date with stdpopsim backend 
num_samples_per_population = config["num_samples_per_population"]
population_id = config["population_id"]
# Here is a list of sample sizes to run msmc on. 
# Each element counts as its own analysis
# so there will be "replicates" runs for each size
num_sampled_genomes_msmc = [int(x) for x in config["num_sampled_genomes_msmc"].split(",")]

# The number of msmc Baumwelch(?) iterations to run,
# typically 20
num_msmc_iterations = config["num_msmc_iterations"]

num_sampled_genomes_per_replicate = config["num_sampled_genomes_per_replicate"]

# The number of replicates of each analysis you would like to run
# For now leaving it a 1 just to get results quickly
replicates = config["replicates"]


# Where you would like all output files from analysis to live
output_dir = os.path.abspath(config["config"])

# The analysis species
species = stdpopsim.get_species(config["species"])

# The specific model you would like to run
if(config["model"] == "PiecewiseConstantSize"):
    model = stdpopsim.PiecewiseConstantSize(species.population_size)
    generation_time = species.generation_time
else:
    model = species.get_demographic_model(config["model"])
    # For plotting
    generation_time = model.generation_time

# The genetic map you would like to use.
# if value None is given default_recombination_rates are
# used with a flat map
genetic_map_id = config["genetic_map"]

# The DFE id used for selection analyses
dfe_id = config["dfe_list"][0] # need to generalize to more than one...

# The GFF annotation id defining where selection will be simulated
annotation_id, selection = config.get("annotation_id", None).split(",")

# The names of all chromosomes to simulate, separated by commas
# Use "all" to simulate all chromosomes for the genome
chrm_list = [chrom.id for chrom in species.genome.chromosomes]
if "chrY" in chrm_list:
    chrm_list.remove("chrY")
if(config["chrm_list"] != "all"):
    chrm_list = [chr for chr in config["chrm_list"].split(",")]


# This grabs the default mr from the first chromosome,
# Ultimitely This needs to be replaced with the weighted average
# of all chromosomes: This should be done in stdpopsim. 
mutation_rate = species.genome.mean_mutation_rate


# ###############################################################################
# GENERAL RULES & GLOBALS
# ###############################################################################


seed_array = np.random.random_integers(1,2**31,replicates)
genetic_map_downloaded_flag= ".genetic_map_downloaded"
msmc_exec = "../ext/msmc/build/msmc"
stairwayplot_code = "stairwayplot/swarmops.jar"

try:
    mask_file = config["mask_file"]
except KeyError:
    mask_file = None

# Run full pipeline!
rule all:
   input: output_dir + f"/Results/all_estimated_Ne_{selection}.pdf"

## Run only the simulations!
#rule all:
#    input: expand(output_dir + "/Intermediate/{seeds}/{chrms}.trees", 
#                    seeds=seed_array, chrms=chrm_list) 

## Run only stairwayplot and plot with coalescent rate!
#rule all:
#   input: expand(output_dir + '/Results/stairwayplot_{selection}.pdf', selection=selection)

## Run only smc+++ 
#rule all:
#    input: expand(output_dir + "/Intermediate/{seeds}/{chrms}_{selection}.trees.smc.gz", seeds=seed_array, chrms=chrm_list, selection=selection) 

## Run only mcmc
#rule all:
#    input: expand(output_dir+"/Results/msmc_estimated_Ne_{selection}.png", selection=selection)

rule download_genetic_map:
    output: genetic_map_downloaded_flag
    message: "Downloading default genetic map"
    run:
        # We need to have this here to avoid several threads trying to download the 
        # the genetic map into the cache at the same time.
        if genetic_map_id is not None:
            genetic_map = species.get_genetic_map(genetic_map_id)
            if not genetic_map.is_cached():
                genetic_map.download()
            with open(output[0], "w") as f:
                print("File to indicate genetic map has been downloaded", file=f)


rule simulation:
    input: 
        genetic_map_downloaded_flag,
        # rules.top_directory.output,
    output:
        output_dir + "/Intermediate/{seeds}/{chrms}_{selection}.trees"
    # TODO get simulation parameters from stdpopsim, so we can share them easily 
    # with anlysis code below?
    threads: 1 
    run:
        contig = species.get_contig(wildcards.chrms, genetic_map=genetic_map_id)
        samples = model.get_samples(*num_samples_per_population)
        engine = stdpopsim.get_engine("slim") ## here we use the slim engine

        # Adding DFE/selection to the simulation  
        dfe = species.get_dfe(dfe_id)

        if annotation_id == "all":
            # Adding selection to the whole contig
            contig.add_dfe(intervals=np.array([[0, int(contig.length)]]), DFE=dfe)

        if annotation_id == "none":
            # if selection is not specified then a neutral model is expected
            contig = species.get_contig(wildcards.chrms, genetic_map=genetic_map_id)

        else:
            ## Adding annotation only seletion on exon region
            annot = species.get_annotations(annotation_id)
            annot_intervals = annot.get_chromosome_annotations(wildcards.chrms)
            contig.add_dfe(intervals=annot_intervals, DFE=dfe)

        ts = engine.simulate(model, contig, samples, seed=wildcards.seeds, slim_scaling_factor=config["slim_scaling_factor"],
            slim_burn_in=10)
        ts.dump(output[0])



# ###############################################################################
# STAIRWAYPLOT
# ###############################################################################


rule sp_download:
    output: 
        stairwayplot_code
    message: 
        "downloading stairwayplot"
    threads: 20
    shell:
        "wget http://sesame.uoregon.edu/~adkern/stdpopsim/stairwayplot.tar.gz && \
            tar zxf stairwayplot.tar.gz"


rule run_stairwayplot:
    input:
        expand(output_dir + "/Intermediate/{seeds}/{chrms}_{selection}.trees",
            chrms=chrm_list, seeds=seed_array, selection=selection),
        stairwayplot_code,
    output: output_dir + "/Results/{seeds}/stairwayplot_estimated_Ne_{selection}.txt"
    threads: 20
    run:
        inputs = expand(output_dir + "/Intermediate/{seeds}/{chrms}_{selection}.trees",
            seeds=wildcards.seeds, chrms=chrm_list, selection=selection)
        # fix here to be able to run a list of selection items in one goal
        runner = stairway.StairwayPlotRunner(
            workdir= output_dir + "/stairwayplot/" + wildcards.seeds+"/",
            stairway_dir=pathlib.Path.cwd() / "stairwayplot")
        runner.ts_to_stairway(inputs, num_bootstraps=200, mask_file=mask_file, selection=selection)
        runner.run_theta_estimation(max_workers=threads, show_progress=True, selection=selection)
        runner.run_summary(output, mutation_rate=mutation_rate, generation_time=generation_time, selection=selection)


def ne_files(wildcards):
    return expand(output_dir + "/Results/{seeds}/stairwayplot_estimated_Ne_{selection}.txt",
            seeds=seed_array, chrms=chrm_list, selection=selection)


rule compound_stairwayplot:
    input:
        ne_files
    output:
        output_dir + "/stairwayplot_estimated_Ne_{selection}.png"
    run: plots.plot_compound_Ne_estimate(model, input, output[0])


rule plot_stairwayplot:
    input:
        f1 = ne_files
    output:
        output_dir + "/Results/stairwayplot_{selection}.pdf"
    run:
        steps=None
        if config["model"] == "GenericConstantSize":
            max_time = species.GenericConstantSize().default_population_size
            max_time *= 2 # 4?
            steps = np.linspace(1, max_time, max_time+1)
        plots.plot_stairwayplot_coalrate(input.f1, output[0],
                    model=model, n_samp=num_sampled_genomes_per_replicate,
                    generation_time=generation_time, species=config["species"],
                    pop_id=population_id, steps=steps, selection=selection)

# ###############################################################################
# SMC++
# ###############################################################################


rule ts_to_smc:
    input:rules.simulation.output
    output: output_dir + "/Intermediate/{seeds}/{chrms}_{selection}.trees.smc.gz"
    run: smc.write_smcpp_file(input[0], mask_file=None, selection=selection) # Including mask file when it works


rule run_smcpp:
    input:
        expand(output_dir+ "/Intermediate/{seeds}/{chrms}_{selection}.trees.smc.gz", 
            chrms=chrm_list, seeds=seed_array, selection=selection)
    output:
        output_dir + "/Intermediate/{seeds}/trees.smc.gz.final.json"
    threads: 20
    run:
        # need to cd into subdir because smc++ crashes otherwise
        cur = os.getcwd()
        os.chdir(f"{output_dir}/Intermediate/{wildcards.seeds}")
        inputs = expand("{chrms}_{selection}.trees.smc.gz", chrms=chrm_list, selection=selection)
        inputs = " ".join(inputs)
        base = f"trees.smc.gz"
        # TODO get the rate here from stdpopsim
        smc.run_smcpp_estimate(inputs, base, mutation_rate=mutation_rate, ncores=threads)
        # need to cd out of subdir for snakemake sanity
        os.chdir(cur)


rule smcpp_plot:
    input: 
        rules.run_smcpp.output
    output: 
        output_dir + "/Results/{seeds}/trees.smc.gz.final.json.csv"
    run:
        # TODO get the genetion time from std source
        smc.run_smcpp_plot(input[0], output[0], generation_time=generation_time)


def ne_files_smcpp(wildcards):
    return expand(output_dir + "/Results/{seeds}/trees.smc.gz.final.json.csv",
            seeds=seed_array, chrms=chrm_list)


rule compound_smcpp:
    input: ne_files_smcpp
    output: output_dir + "/Results/smcpp_estimated_Ne.png"
    run: plots.plot_compound_smcpp(input, output[0], model, num_sampled_genomes_per_replicate, generation_time)


# ###############################################################################
# MSMC
# ###############################################################################

rule ts_to_multihep:
    input: rules.simulation.output
    output: output_dir + "/Intermediate/{seeds}/{samps}.{chrms}_{selection}.trees.multihep.txt"
    run: msmc.write_msmc_file(input[0], num_sampled_genomes_msmc, selection, mask_file)


rule run_msmc:
    input:
        # TODO make this NOT dependent on all simulations.
        # is there anyway to get access to wildcards.seeds from here? 
        expand(output_dir + "/Intermediate/{seeds}/{samps}.{chrms}_{selection}.trees.multihep.txt",
            chrms=chrm_list, seeds=seed_array, samps=num_sampled_genomes_msmc, selection=selection)
    output: output_dir + "/Intermediate/{seeds}/{samps}.{selection}.trees.multihep.txt.final.txt"
    threads: 8 
    run: 
        inputs = expand(output_dir + "/Intermediate/{seeds}/{samps}.{chrms}_{selection}.trees.multihep.txt",
            seeds=wildcards.seeds, samps=wildcards.samps, chrms=chrm_list, selection=selection)
        input_file_string = " ".join(inputs)
        output_file_string = output_dir + f"/Intermediate/{wildcards.seeds}/{wildcards.samps}.{selection}.trees.multihep.txt"
        print("This is the string")
        print(output_file_string)
        msmc.run_msmc_estimate(input_file_string, output_file_string, msmc_exec,
            iterations=num_msmc_iterations, ncores=threads)


rule convert_msmc:
    input: rules.run_msmc.output
    output: output_dir + "/Results/{seeds}/{samps}.{selection}.trees.multihep.txt.final.txt.csv"
    run: msmc.convert_msmc_output(input[0] ,output[0], mutation_rate=mutation_rate, generation_time=generation_time)


def ne_files_msmc(wildcards):
    return expand(output_dir + "/Results/{seeds}/{samps}.{selection}.trees.multihep.txt.final.txt.csv",
            seeds=seed_array,samps=num_sampled_genomes_msmc, selection=selection)


rule compound_msmc:
    input: ne_files_msmc,
    output: output_dir+f"/Results/msmc_estimated_Ne_{selection}.png"
    run: plots.plot_compound_msmc(input, output[0], model)


# ###############################################################################
#  Plotting results
# ###############################################################################


rule all_plot:
    input:
        f1 = ne_files,
        #f2 = ne_files_smcpp,
        f3 = ne_files_msmc,
    output:
        output_dir + f"/Results/all_estimated_Ne_{selection}.pdf"
    run:
        steps=None
        if config["model"] == "GenericConstantSize":
            max_time = species.GenericConstantSize().default_population_size
            max_time *= 4 # 2?
            steps = np.linspace(1, max_time, max_time+1)
            # , input.f2
            # We need to transform that into a dictionary
        num_samples_per_population = {'YRI':20, 'CEU':0, 'CHB':0}
        plots.plot_all_ne_estimates(input.f1, input.f3, output[0], model=model, n_samp=num_samples_per_population, generation_time=generation_time, species=config["species"], pop_id=population_id, steps=steps, selection=selection)


rule clean:
    shell:
         f"rm -rf stairwayplot \
            stairwayplot.tar.gz \
            {output_dir}/Intermediate \
            {output_dir}/Results \
            {output_dir}/stairwayplot \
            .genetic_map_downloaded \
            rm -rf .snakemake"
